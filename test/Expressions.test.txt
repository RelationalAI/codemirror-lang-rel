# Single Expression

@inline
@static(1, :rel)
{
    1 + 2;
    2023-07-01;
    2023-07-01T00:00:00Z
}

==>

Rel(
    Annotation(AnnotationKeyword(BasicId)),
    Annotation(
        AnnotationKeyword(BasicId),
        AnnotationParams(IntLiteral,RelnameLiteral)),
    UnionExpression(
        UnionExpression(
            BasicExpression(
                BasicExpression(IntLiteral),
                OperatorKeyword,
                BasicExpression(IntLiteral)),
            BasicExpression(DateLiteral)),
        BasicExpression(DateTimeLiteral)))


# Interpolation
def output = """
    // A single comment
    /***
        A block comment
    ***/
    %(
        string_join["\n", {
            """
            // Comment in a string
                def n[x] = %(
                    x + 1
                )
            """
        }]
    )

"""

def a = "%b"

==>

Rel(
    DefinitionDeclaration(
        Keyword,
        LhsId(Emphasis),
        BasicExpression(
            InterpolationMultilineLiteral(
                InterpolationExpression(
                    BasicExpression(
                        PartialApplicationExpression(
                            BasicExpression(BasicId),
                            V1BasicActual(BasicExpression(StaticStringLiteral)),
                            V1BasicActual(BasicExpression(
                                BoundedExpression(
                                    BasicExpression(
                                        InterpolationMultilineLiteral(
                                            InterpolationExpression(
                                                BasicExpression(
                                                    BasicExpression(BasicId),
                                                    OperatorKeyword,
                                                    BasicExpression(IntLiteral)))))))))))))),
    DefinitionDeclaration(
        Keyword,
        LhsId(BasicId),
        BasicExpression(InterpolationLiteral(InterpolationId))))

# Empty Expression

def a = {}
def b = {;}
def c = {,}

==>

Rel(
    DefinitionDeclaration(
        Keyword,
        LhsId(BasicId),
        BasicExpression(BoundedExpression)),
    DefinitionDeclaration(
        Keyword,
        LhsId(BasicId),
        BasicExpression(BoundedExpression)),
    DefinitionDeclaration(
        Keyword,
        LhsId(BasicId),
        BasicExpression(BoundedExpression)))

# Expression with Trailing Comma/Semicolon

def G = create_graph[{(:weight, W)}, {(:is_weighted,);}]

==>

Rel(
    DefinitionDeclaration(
        Keyword,
        LhsId(BasicId),
        BasicExpression(
            PartialApplicationExpression(
                BasicExpression(BasicId),
                V1BasicActual(
                    BasicExpression(
                        BoundedExpression(
                            BasicExpression(
                                BoundedExpression(
                                    ProductExpression(
                                        BasicExpression(RelnameLiteral),
                                        BasicExpression(BasicId))))))),
                V1BasicActual(
                    BasicExpression(
                        BoundedExpression(
                            UnionExpression(
                                BasicExpression(
                                    BoundedExpression(
                                        ProductExpression(BasicExpression(RelnameLiteral))))))))))))

# Specialize

def a = #("test")

==>

Rel(
    DefinitionDeclaration(
        Keyword,
        LhsId(BasicId),
        BasicExpression(SpecializeExpression(BasicExpression(StaticStringLiteral)))))

# Operators

def output { my_higher_order[{+}, 1, 2] }
def output { {+}[1, 2] }

==>

Rel(
    DefinitionDeclaration(
        Keyword,
        LhsId(Emphasis),
        BasicExpression(
            PartialApplicationExpression(
                BasicExpression(BasicId),
                V1BasicActual(
                    BasicExpression(CurlyOpId(Operator))),
                V1BasicActual(
                    BasicExpression(IntLiteral)),
                V1BasicActual(BasicExpression(IntLiteral))))),
    DefinitionDeclaration(
        Keyword,
        LhsId(Emphasis),
        BasicExpression(
            PartialApplicationExpression(
                BasicExpression(CurlyOpId(Operator)),
                V1BasicActual(BasicExpression(IntLiteral)),
                V1BasicActual(BasicExpression(IntLiteral))))))

# Exists/Forall

def a { exists( (x, y) | foo(x, y) and x > y ) }
def b { forall( (x, y) | foo(x, y) implies x > y ) }

==>

Rel(
    DefinitionDeclaration(
        Keyword,
        LhsId(BasicId),
        BasicExpression(
            Keyword,
            Bindings(VarDecl(BasicId),VarDecl(BasicId)),
            BasicExpression(
                BasicExpression(
                    ApplicationExpression(
                        BasicExpression(BasicId),
                        V1BasicActual(BasicExpression(BasicId)),
                        V1BasicActual(BasicExpression(BasicId)))),
                Keyword,
                BasicExpression(
                    BasicExpression(BasicId),
                    OperatorKeyword,
                    BasicExpression(BasicId))))),
    DefinitionDeclaration(
        Keyword,
        LhsId(BasicId),
        BasicExpression(
            Keyword,
            Bindings(VarDecl(BasicId),VarDecl(BasicId)),
            BasicExpression(
                BasicExpression(
                    ApplicationExpression(
                        BasicExpression(BasicId),
                        V1BasicActual(BasicExpression(BasicId)),
                        V1BasicActual(BasicExpression(BasicId)))),
                Keyword,
                BasicExpression(
                    BasicExpression(BasicId),
                    OperatorKeyword,
                    BasicExpression(BasicId))))))

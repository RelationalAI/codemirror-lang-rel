# Module Declaration

module store def a = 1 end

==>

Rel(
    ModuleDeclaration(
        Keyword,
        LhsId(BasicId),
        DefinitionDeclaration(
            Keyword,
            LhsId(BasicId),
            BasicExpression(IntLiteral)),
        Keyword))

# Namespace Declaration

namespace store def a = 1 end

==>

Rel(
    NamespaceDeclaration(
        Keyword,
        LhsId(BasicId),
        DefinitionDeclaration(
            Keyword,
            LhsId(BasicId),
            BasicExpression(IntLiteral)),
        Keyword))

# Value-Type Declaration

value type Distance = Float

==>

Rel(
    ValueTypeDeclaration(
        Keyword,
        Keyword,
        LhsId(BasicId),
        BasicExpression(BasicId)))

# Entity-Type Declaration

entity type Professional = String, String

==>

Rel(
    EntityTypeDeclaration(
        Keyword,
        Keyword,
        LhsId(BasicId),
        ProductExpression(
            BasicExpression(BasicId),
            BasicExpression(BasicId))))

# Constraint Declaration

ic() {
    student âŠ† person
    // Can also be written as `subset(student, person)`.
}

ic my_ic(x) requires { foo(x) implies x > 0 }

==>

Rel(
    ConstraintDeclaration(
        Keyword,
        BasicExpression(
            BasicExpression(BasicId),
            OperatorKeyword,
            BasicExpression(BasicId)),
        LineComment),
    ConstraintDeclaration(
        Keyword,
        LhsId(BasicId),
        Bindings(VarDecl(BasicId)),
        Keyword,
        BasicExpression(
            BasicExpression(
                ApplicationExpression(
                    BasicExpression(BasicId),
                    V1NocommaActual(BasicExpression(BasicId)))),
            Keyword,
            BasicExpression(
                BasicExpression(BasicId),
                OperatorKeyword,
                BasicExpression(IntLiteral)))))

# Bound Declaration

bound R = Int

==>

Rel(
    BoundDeclaration(
        Keyword,
        LhsId(BasicId),
        BasicExpression(BasicId)))

# With-Use Declaration

with mod use a, b, c

==>

Rel(
    WithUseDeclaration(
        Keyword,
        BasicExpression(BasicId),
        Keyword,
        Alias(BasicId),
        Alias(BasicId),
        Alias(BasicId)))

# From-Import Declaration

from ns::subns import a, b, c

==>

Rel(
    ImportDeclaration(
        Keyword,
        LhsId(QualifiedName(QualifiedNameId(BasicId),QualifiedNameElem)),
        Keyword,
        ImportAlias(BasicId),
        ImportAlias(BasicId),
        ImportAlias(BasicId)))

# Nested-Module Declaration

module mod
    module submod
        def a = 1
    end
end

==>

Rel(
    ModuleDeclaration(
        Keyword,
        LhsId(BasicId),
        ModuleDeclaration(
            Keyword,
            LhsId(BasicId),
            DefinitionDeclaration(
                Keyword,
                LhsId(BasicId),
                BasicExpression(IntLiteral)),
            Keyword),
        Keyword))

# Nested-Namespace Declaration

namespace ns
    namespace subns
        def a = 1
    end
end

==>

Rel(
    NamespaceDeclaration(
        Keyword,
        LhsId(BasicId),
        NamespaceDeclaration(
            Keyword,
            LhsId(BasicId),
            DefinitionDeclaration(
                Keyword,
                LhsId(BasicId),
                BasicExpression(IntLiteral)),
            Keyword),
        Keyword))

# Declare Bound Declaration

declare foo (x...) requires {(:hi, FilePos, String)}(x...)

==>

Rel(
    DeclareBoundDeclaration(
        Keyword,
        LhsId(BasicId),
        Bindings(VarDecl(BasicId)),
        Keyword,
        BasicExpression(
            ApplicationExpression(
                BasicExpression(
                    BoundedExpression(
                        BasicExpression(
                            BoundedExpression(
                                ProductExpression(
                                    ProductExpression(
                                        BasicExpression(RelnameLiteral),
                                        BasicExpression(BasicId)),
                                    BasicExpression(BasicId)))))),
                V1NocommaActual(BasicExpression(BasicId))))))

# CoreRel Definition

def foo { 100 }
def bar[] : 200
def baz(x, y) : x > y
def fred[x, y] : x + y

==>

Rel(
    DefinitionDeclaration(
        Keyword,
        LhsId(BasicId),
        BasicExpression(IntLiteral)),
        DefinitionDeclaration(
            Keyword,
            LhsId(BasicId),
            BasicExpression(IntLiteral)),
        DefinitionDeclaration(
            Keyword,
            LhsId(BasicId),
            Bindings(VarDecl(BasicId),VarDecl(BasicId)),
            BasicExpression(
                BasicExpression(BasicId),
                OperatorKeyword,
                BasicExpression(BasicId))),
        DefinitionDeclaration(
            Keyword,
            LhsId(BasicId),
            Bindings(VarDecl(BasicId),VarDecl(BasicId)),
            BasicExpression(
                BasicExpression(BasicId),
                OperatorKeyword,
                BasicExpression(BasicId))))

# CoreRel Value-Type Declaration

value type Interval (x, y) : Int(x) and Int(y) and x < y
value type RGB { (Int, Int, Int) }

==>

Rel(
    ValueTypeDeclaration(
        Keyword,
        Keyword,
        LhsId(BasicId),
        Bindings(VarDecl(BasicId),VarDecl(BasicId)),
        BasicExpression(
            BasicExpression(
                BasicExpression(
                    ApplicationExpression(
                        BasicExpression(BasicId),
                        V1NocommaActual(BasicExpression(BasicId)))),
                Keyword,
                BasicExpression(
                    ApplicationExpression(
                        BasicExpression(BasicId),
                        V1NocommaActual(BasicExpression(BasicId))))),
                Keyword,
                    BasicExpression(
                        BasicExpression(BasicId),
                        OperatorKeyword,
                        BasicExpression(BasicId)))),
    ValueTypeDeclaration(
        Keyword,
        Keyword,
        LhsId(BasicId),
        BasicExpression(
            BoundedExpression(
                ProductExpression(
                    ProductExpression(
                        BasicExpression(BasicId),
                        BasicExpression(BasicId)),
                    BasicExpression(BasicId))))))

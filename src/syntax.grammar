@top Rel { declaration+ | Annotation* Expression }

@skip { spaces | newLine | LineComment | BlockComment }

@precedence {
    field @left,
    appl @left,
    power @right,
    unary,
    param @left,
    mul @left,
    add @left,
    join @left,
    union @left,
    compL @left,
    compR @right,
    not,
    quant,
    and @left,
    or @left,
    impliesR @right,
    impliesL @left,
    iff @right,
    xor @right,
    relname @left,
    abstract @left,
    parenOp,
    annot
}

declaration[@isGroup=Declaration] {
    DefinitionStatement |
    BoundStatement |
    ValueTypeStatement |
    EntityTypeStatement |
    ConstraintStatement |
    ModuleStatement |
    UseStatement
}

/*
 * Docstring Statement
 */

// Not ideal since RawStringSequence takes precedence over
// DocstringLiteral/MultilineDocstringLiteral and reversing the
// precedence won't catch Raw String

// TODO use local tokens for all strings or define an external tokenizer
// see https://lezer.codemirror.net/docs/guide/#local-token-groups

Docstring {
    kw<"doc"> DocstringLiteral |
    kw<"doc"> MultilineDocstringLiteral |
    kw<"doc"> RawStringSequence
}

/*
 * Annotation Statement
 */

AnnotationKeyword {
    annotationKw<"function"> |
    annotationKw<"inline"> |
    annotationKw<"ondemand"> |
    annotationKw<"outline"> |
    annotationKw<"static"> |
    annotationKw<"no_diagnostics">
}

AnnotationParams { commaSep1<BaseLiteral> }

Annotation { AnnotationKeyword ( !annot "(" AnnotationParams ")" )? }

/*
 * Declaration Statements
 */

DefinitionStatement {
    Docstring? Annotation* kw<"def"> LhsId FormalParamsBracket* FormalParamsParen? ( "=" Expression | "{" Expression "}" )
}

BoundStatement {
    Docstring? Annotation* kw<"bound"> LhsId FormalParamsBracket* FormalParamsParen? ( "=" Expression | "{" Expression "}" )?
}

ValueTypeStatement {
    Docstring? Annotation* kw<"value"> kw<"type"> LhsId ( FormalParamsBracket* FormalParamsParen? ( "=" Expression | "{" Expression "}" ) )?
}

EntityTypeStatement {
    Docstring? Annotation* kw<"entity"> kw<"type"> LhsId ( FormalParamsBracket* FormalParamsParen? ( "=" Expression | "{" Expression "}" ) )?
}

ConstraintStatement {
    Docstring? Annotation* kw<"ic"> LhsId? FormalParamsBracket* FormalParamsParen? ( "=" Expression | "{" Expression "}" )
}

ModuleStatement {
    Docstring? Annotation* kw<"module"> LhsId FormalParamsBracket* declaration* kw<"end">
}

UseStatement {
    kw<"with"> Expression kw<"use"> ("..." | commaSep1<Alias>)
}

id { BasicId | ConstructorId | kw<"type"> | kw<"entity"> | kw<"value"> }

ParenOpId { "(" Operator !parenOp ")" }

LhsId {
    id |
    ParenOpId |
    QualifiedName |
    emphasisKeyword
}

AliasId { ( id | Operator ) }

Alias { ( id | Operator ) ( kw<"as"> AliasId )? }

QualifiedNameId {
    emphasisKeyword |
    BasicId ~idConflict |
    ConstructorId |
    ParenOpId ~parenOpConflict
}

QualifiedName { QualifiedNameId QualifiedNameElem+ }

emphasisKeyword[@dynamicPrecedence=1] {
    emp<"output"> |
    emp<"insert"> |
    emp<"delete"> |
    emp<"abort"> |
    emp<"export">
}

/*
 * Literals
 */

@external tokens rawString from "./tokenizers.js" {
  RawStringSequence
}

RawStringLiteral {
    kw<"raw"> RawStringSequence
}

Interpolation {
    InterpolationId |
    InterpolationExpression
}

InterpolationExpression { "%(" Expression ")" }

InterpolationLiteral {
    quote1 staticStringPart? Interpolation (staticStringPart | Interpolation)* quote1
}

InterpolationMultilineLiteral {
    quote3 staticMultilineStringPart? Interpolation (staticMultilineStringPart | Interpolation)* quote3
}

BaseLiteral {
    IntLiteral |
    FloatLiteral |
    RelnameLiteral |
    RelnameStringLiteral |
    RelnameMultilineStringLiteral |
    StaticStringLiteral |
    StaticMultilineStringLiteral |
    CharLiteral |
    DateLiteral |
    DateTimeLiteral |
    RawStringLiteral
}

Literal {
    BaseLiteral |
    BooleanLiteral |
    SpecializeIntLiteral |
    InterpolationLiteral |
    InterpolationMultilineLiteral
}

/*
 * Expressions
 */

BasicExpression {
    id "..."? ~idConflict |
    ParenOpId ~parenOpConflict |
    QualifiedName |
    Literal ~literalConflict |
    SpecializeExpression |
    "_" |
    BasicExpression !field op<"."> BasicExpression |
    PartialApplicationExpression |
    ApplicationExpression |
    BasicExpression !power op<"^"> BasicExpression |
    !unary op<"-"> BasicExpression |
    BasicExpression !mul op<"/"> BasicExpression |
    BasicExpression !mul op<"%"> BasicExpression |
    BasicExpression !mul op<"*"> BasicExpression |
    BasicExpression !mul op<"÷"> BasicExpression |
    BasicExpression !mul op<"×"> BasicExpression |
    BasicExpression !mul op<"⊗"> BasicExpression |
    BasicExpression !mul op<"⊙"> BasicExpression |
    BasicExpression !add op<"+"> BasicExpression |
    BasicExpression !add op<"-"> BasicExpression |
    BasicExpression !add op<"∩"> BasicExpression |
    BasicExpression !add op<"⊕"> BasicExpression |
    BasicExpression !union op<"∪"> BasicExpression |
    BasicExpression !add op<"⊓"> BasicExpression |
    BasicExpression !union op<"⊔"> BasicExpression |
    BasicExpression !compL op<"="> BasicExpression |
    BasicExpression !compL op<"!="> BasicExpression |
    BasicExpression !compL op<"≈"> BasicExpression |
    BasicExpression !compL op<"∼"> BasicExpression |
    BasicExpression !compR op<"→"> BasicExpression |
    BasicExpression !compL op<"←"> BasicExpression |
    BasicExpression !compL op<"≼"> BasicExpression |
    BasicExpression !compL op<"≽"> BasicExpression |
    BasicExpression !compL op<"≺"> BasicExpression |
    BasicExpression !compL op<"≻"> BasicExpression |
    BasicExpression !compL op<"≠"> BasicExpression |
    BasicExpression !compL op<"<"> BasicExpression |
    BasicExpression !compL op<">"> BasicExpression |
    BasicExpression !compL op<"<="> BasicExpression |
    BasicExpression !compL op<"≤"> BasicExpression |
    BasicExpression !compL op<">="> BasicExpression |
    BasicExpression !compL op<"≥"> BasicExpression |
    BasicExpression !compL op<"⊆"> BasicExpression |
    BasicExpression !compL op<"⊇"> BasicExpression |
    BasicExpression !compL op<"⊂"> BasicExpression |
    BasicExpression !compL op<"⊃"> BasicExpression |
    BoundedExpression |
    kw<"if"> Expression kw<"then"> Expression kw<"else"> Expression kw<"end"> |
    ( kw<"forall"> | "∀" ) "(" Bindings ":" Expression ")"
}

PartialApplicationExpression {
    BasicExpression !appl "[" NocommaParam? "]" |
    BasicExpression !appl "[" commaSep2<LogicalParam> "]"
}

ApplicationExpression {
    BasicExpression !appl "(" NocommaParam? ")" |
    BasicExpression !appl "(" commaSep2<LogicalParam> ")"
}

BoundedExpression {
    "(" Expression? ( "," | ";" )? ")" |
    "{" Expression? ( "," | ";" )? "}"
}

LogicalExpression {
    BasicExpression |
    !quant (kw<"exists"> | "∃") LogicalExpression |
    !quant (kw<"exists"> | "∃") LogicalAbstractExpression |
    LogicalExpression !and ( kw<"and"> | op<"∧"> ) LogicalExpression |
    LogicalExpression !or ( kw<"or"> | op<"∨"> ) LogicalExpression |
    LogicalExpression !impliesR ( kw<"implies"> | op<"⇒"> ) LogicalExpression |
    LogicalExpression !impliesL op<"⇐"> LogicalExpression |
    !not ( kw<"not"> | op<"¬"> ) LogicalExpression |
    LogicalExpression !iff ( kw<"iff"> | op<"≡"> | op<"⇔"> ) LogicalExpression |
    LogicalExpression !xor ( kw<"xor"> | op<"≢"> | op<"⇎"> | op<"⊻"> ) LogicalExpression
}

Bindings {
    FormalParams ( kw<"where"> LogicalExpression )? |
    "(" Bindings ")"
}

AbstractExpression {
    Bindings !abstract ":" Expression |
    UnionExpression !abstract ( kw<"for"> | "|" | kw<"from">) Bindings
}

LogicalAbstractExpression {
    Bindings !abstract ":" LogicalExpression |
    LogicalExpression !abstract ( kw<"for"> | "|" | kw<"from">) Bindings
}

NocommaAbstractExpression {
    Bindings !abstract ":" NocommaExpression |
    NocommaUnionExpression !abstract ( kw<"for"> | "|" | kw<"from">) Bindings
}

RestrictExpression {
    LogicalExpression |
    RestrictExpression ( op<"<:"> | op<":>"> ) LogicalExpression
}

OverrideExpression {
    RestrictExpression |
    OverrideExpression ( op<"<++"> | op<"++>"> ) RestrictExpression
}

JoinExpression {
    OverrideExpression |
    JoinExpression !join "," OverrideExpression
}

UnionExpression {
    JoinExpression |
    UnionExpression !union ";" JoinExpression
}

Expression { UnionExpression | AbstractExpression }

SpecializeExpression { "#(" Expression ")" }

NocommaUnionExpression {
    OverrideExpression |
    NocommaUnionExpression !union ";" OverrideExpression
}

NocommaExpression { NocommaUnionExpression | NocommaAbstractExpression }

LogicalParam { Operator ~operatorConflict | LogicalExpression }

NocommaParam { Operator ~operatorConflict | NocommaExpression }

FormalParam {
    Literal ~literalConflict |
    Operator ~operatorConflict |
    (id "..."? ~idConflict ) (( kw<"in"> | op<"∈"> ) BasicExpression)?
}

FormalParams { FormalParam ( !param "," FormalParam )* }

FormalParamsBracket { "[" FormalParams? "]" }

FormalParamsParen { "(" FormalParams? ")" }

@tokens {
    spaces[@export] { $[\u0009 \u000b\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]+ }
    newLine[@export] { $[\r\n\u2028\u2029] }

    idCharSingle {
        $[a-zA-Zα-ωΑ-Ω]
    }
    idCharInit {
        $[a-zA-Zα-ωΑ-Ω_]
    }
    idChar {
        $[a-zA-Zα-ωΑ-Ω_0-9]
    }
    basicIdentifier { idCharSingle | idCharInit idChar+ }
    BasicId { basicIdentifier }
    ConstructorId { "^" basicIdentifier }

    Operator {
        "." |
        "^" |
        "/" |
        "%" |
        "*" |
        "÷" |
        "×" |
        "⊗" |
        "⊙" |
        "-" |
        "+" |
        "⊕" |
        "∩" |
        "∪" |
        "⊔" |
        "⊓" |
        "=" |
        "!=" |
        "≈" |
        "∼" |
        "≠" |
        "<" |
        ">" |
        "<=" |
        "≤" |
        ">=" |
        "≥" |
        "∈" |
        "⊆" |
        "⊇" |
        "⊂" |
        "⊃" |
        "≼" |
        "≽" |
        "≺" |
        "≻" |
        "¬" |
        "∧" |
        "∨" |
        "→" |
        "←" |
        "⇒" |
        "⇐" |
        "≡" |
        "⇔" |
        "⊻" |
        "≢" |
        "⇎" |
        "<:" |
        ":>" |
        "<++" |
        "++>"
    }

    decimalLiteral { $[0-9]+ }
    octalLiteral { "0o" $[0-7]+ }
    hexadecimalLiteral { "0x" $[0-9A-Fa-f]+ }
    IntLiteral { decimalLiteral | octalLiteral | hexadecimalLiteral }
    SpecializeIntLiteral { "#" IntLiteral }

    exponent { $[eE] $[+-]? decimalLiteral }
    floatLiteral1 { decimalLiteral "." decimalLiteral? exponent? }
    floatLiteral2 { decimalLiteral exponent }
    floatLiteral3 { "." decimalLiteral exponent? }
    FloatLiteral { floatLiteral1 | floatLiteral2 | floatLiteral3 }

    DateLiteral { $[0-9] $[0-9] $[0-9] $[0-9] "-" $[0-9] $[0-9] "-" $[0-9] $[0-9] }
    hourMinuteDigits { $[0-9] $[0-9] ":" $[0-9] $[0-9] }
    timeDigits { $[0-9] $[0-9] ":" $[0-9] $[0-9] ":" $[0-9] $[0-9] }
    timezone { "Z" | $[+-]? hourMinuteDigits }
    DateTimeLiteral { DateLiteral "T" timeDigits timezone }

    BooleanLiteral { "true" | "false" }

    EscapeChar {
        '\\' ('\\' | '%' |
            $['"abefnrtv0-7] |
            $[0-7]$[0-7] |
            $[0123]$[0-7]$[0-7] |
            'x' $[0-9a-fA-F]$[0-9a-fA-F] |
            'u' $[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F] |
            'U' $[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F])
    }
    staticChar { !["\r\n\\%] }
    multiStaticChar { !["\\%] }

    staticSequence { staticChar | EscapeChar }
    multiStaticSequence { '"'? '"'? ( multiStaticChar | EscapeChar ) }
    StaticStringLiteral { '"' staticSequence* '"' }
    StaticMultilineStringLiteral { '"""' multiStaticSequence* '"""' }

    staticStringPart { staticSequence+ }
    staticMultilineStringPart { multiStaticSequence+ }

    DocstringLiteral { quote1 (!["\r\n\\] | EscapeChar)* quote1 }
    MultilineDocstringLiteral {
        quote3 ( quote1? quote1? (!["\\] | EscapeChar))* quote3
    }

    RelnameLiteral { ( ":" "^"? (basicIdentifier | "_") | ":[]" ) }
    RelnameStringLiteral { ":" StaticStringLiteral }
    RelnameMultilineStringLiteral { ":" StaticMultilineStringLiteral }

    QualifiedNameElem { ":" BasicId | ":(" Operator ")" }
    InterpolationId { "%" basicIdentifier }

    quote1 { '"' }
    quote3 { '"""' }

    CharLiteral { "'" ( !['\\] | EscapeChar ) "'" }

    LineComment { "//" ![\n]* }
    BlockComment { "/*" ( ![*] | "*"+ ![/*] )* "*"+ "/" }

    @precedence { spaces newLine BlockComment LineComment DocstringLiteral staticStringPart }
    @precedence { spaces newLine BlockComment LineComment MultilineDocstringLiteral staticMultilineStringPart }
    @precedence { DateTimeLiteral DateLiteral FloatLiteral IntLiteral }
    @precedence { BooleanLiteral BasicId }
    @precedence { ConstructorId Operator }
    @precedence { FloatLiteral Operator }
    @precedence { "..." Operator ":" }
    @precedence { QualifiedNameElem ":" }
    @precedence { RelnameLiteral ":" }
    @precedence { BasicId "_" }
    @precedence { LineComment Operator }
    @precedence { MultilineDocstringLiteral DocstringLiteral }

}

kw<term> { @specialize[@name=Keyword]<BasicId, term> }

annotationKw<term> { "@" term }

emp<term> { @extend[@name=Emphasis]<BasicId, term> }

op<oper> { @extend[@name=OperatorKeyword]<Operator, oper> }

commaSep1<rule> { rule ( !param "," rule )* }

commaSep2<rule> { rule !param "," rule ( !param "," rule )* }

@detectDelim

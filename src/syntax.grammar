@detectDelim

@top Rel { declaration_namespace+ | v1TopLevelExpression }

@skip { spaces | newLine | LineComment | BlockComment }

@precedence {
    dotJoin @left,
    appl @left,
    power @right,
    unary,
    param @left,
    mul @left,
    add @left,
    tripleEqual @left,
    product @left,
    union @left,
    compL @left,
    compR @right,
    not,
    quant,
    and @left,
    or @left,
    impliesR @right,
    impliesL @left,
    restrict @left,
    override @left,
    iffXor @right,
    bind @left,
    abstract @left,
    parenOp,
    annot
}

declaration[@isGroup=Declaration]
    { DefinitionDeclaration
    | BoundDeclaration
    | ValueTypeDeclaration
    | EntityTypeDeclaration
    | ConstraintDeclaration
    | ModuleDeclaration
    | WithUseDeclaration
    | ImportDeclaration
    }

declaration_namespace
    { declaration
    | NamespaceDeclaration
    }


/*
 * Docstring Statement
 */

// Not ideal since RawStringSequence takes precedence over
// DocstringLiteral/MultilineDocstringLiteral and reversing the
// precedence won't catch Raw String

// TODO use local tokens for all strings or define an external tokenizer
// see https://lezer.codemirror.net/docs/guide/#local-token-groups

Docstring
    { xkw<"doc"> DocstringLiteral
    | xkw<"doc"> MultilineDocstringLiteral
    | xkw<"doc"> RawStringSequence
    }

/*
 * Annotation Statement
 */

AnnotationKeyword { "@" BasicId }

AnnotationParams { commaSep1<baseLiteral> }

Annotation { AnnotationKeyword ( !annot "(" AnnotationParams ")" )? }

/*
 * Declarations
 */

DefinitionDeclaration {
    Docstring? Annotation* kw<"def"> LhsId v1FormalsBracket* v1FormalsParen? ( "=" v1expression | "{" v1expression "}" )
}

BoundDeclaration {
    Docstring? Annotation* kw<"bound"> LhsId v1FormalsBracket* v1FormalsParen? ( "=" v1expression | "{" v1expression "}" )?
}

ValueTypeDeclaration {
    Docstring? Annotation* kw<"value"> kw<"type"> LhsId ( v1FormalsBracket* v1FormalsParen? ( "=" v1expression | "{" v1expression "}" ) )?
}

EntityTypeDeclaration {
    Docstring? Annotation* kw<"entity"> kw<"type"> LhsId ( v1FormalsBracket* v1FormalsParen? ( "=" v1expression | "{" v1expression "}" ) )?
}

ConstraintDeclaration {
    Docstring? Annotation* kw<"ic"> LhsId? v1FormalsBracket* v1FormalsParen? ( "=" v1expression | "{" v1expression "}" )
}

ModuleDeclaration {
    Docstring? Annotation* kw<"module"> LhsId v1FormalsBracket* declaration* kw<"end">
}

NamespaceDeclaration {
    Docstring? Annotation* kw<"namespace"> LhsId v1FormalsBracket* declaration_namespace* kw<"end">
}

WithUseDeclaration {
    kw<"with"> v1expression kw<"use"> ("..." | commaSep1<Alias>)
}

ImportDeclaration {
    kw<"from"> LhsId kw<"import"> ("..." | commaSep1<Alias>)
}

id { BasicId | ConstructorId | kw<"value"> | kw<"entity"> | kw<"type"> }

ParenOpId { "(" Operator !parenOp ")" }

LhsId
    { id
    | ParenOpId
    | QualifiedName
    | emphasisKeyword
    | kw<"implies">
    | kw<"iff">
    | kw<"xor">
    }

AliasId { ( id | Operator ) }

Alias { ( id | Operator ) ( kw<"as"> AliasId )? }

QualifiedNameId
    { emphasisKeyword
    | BasicId ~idConflict
    | ConstructorId
    | ParenOpId ~parenOpConflict
    | QualifiedKeyword
    }

// Keywords have to be hardcoded here since they are specialized
// in the grammar to avoid using them as identifiers, except for the case of QualifiedNameId
QualifiedKeyword
    { kw<"def">
    | kw<"bound">
    | kw<"ic">
    | kw<"module">
    | kw<"end">
    | kw<"use">
    | kw<"as">
    | kw<"then">
    | kw<"else">
    | kw<"forall">
    | kw<"and">
    | kw<"or">
    | kw<"implies">
    | kw<"iff">
    | kw<"xor">
    | kw<"where">
    | kw<"for">
    | kw<"from">
    | kw<"value">
    | kw<"entity">
    | kw<"type">
    }

QualifiedName { QualifiedNameId QualifiedNameElem+ }

emphasisKeyword[@dynamicPrecedence=1]
    { emp<"output">
    | emp<"insert">
    | emp<"delete">
    | emp<"abort">
    | emp<"export">
    }

/*
 * Literals
 */

@external tokens rawString from "./tokenizers.js" {
  RawStringSequence
}

RawStringLiteral {
    xkw<"raw"> RawStringSequence
}

interpolation
    { InterpolationId
    | InterpolationExpression
    }

InterpolationExpression { "%(" v1expression ")" }

InterpolationLiteral {
    quote1 staticStringPart? interpolation (staticStringPart | interpolation)* quote1
}

InterpolationMultilineLiteral {
    quote3 staticMultilineStringPart? interpolation (staticMultilineStringPart | interpolation)* quote3
}

baseLiteral
    { IntLiteral
    | FloatLiteral
    | RelnameLiteral
    | RelnameStringLiteral
    | RelnameMultilineStringLiteral
    | StaticStringLiteral
    | StaticMultilineStringLiteral
    | CharLiteral
    | DateLiteral
    | DateTimeLiteral
    | RawStringLiteral
    }

literal
    { baseLiteral
    | BooleanLiteral
    | SpecializeIntLiteral
    | InterpolationLiteral
    | InterpolationMultilineLiteral
    }

/*
 * Expressions
 */

BasicExpression
    { id "..."? ~idConflict
    | "_"
    | QualifiedName
    | ParenOpId ~parenOpConflict

    // literal
    | literal ~literalConflict

    // specialize
    | "#(" v1expression ")"

    | PartialApplicationExpression
    | ApplicationExpression

    // math expressions
    | BasicExpression !dotJoin op<"."> BasicExpression
    | BasicExpression !power op<"^"> BasicExpression
    | !unary op<"-"> BasicExpression
    | BasicExpression !mul
        ( op<"/">
        | op<"%">
        | op<"*">
        | op<"÷">
        | op<"×">
        | op<"⊗">
        | op<"⊙">
        ) BasicExpression
    | BasicExpression !add
        ( op<"+">
        | op<"-">
        | op<"∩">
        | op<"⊕">
        | op<"⊓">
        ) BasicExpression
    | BasicExpression !union ( op<"∪"> | op<"⊔"> ) BasicExpression
    | BasicExpression !compL
        ( op<"=">
        | op<"!=">
        | op<"≈">
        | op<"∼">
        | op<"←">
        | op<"≼">
        | op<"≽">
        | op<"≺">
        | op<"≻">
        | op<"≠">
        | op<"<">
        | op<">">
        | op<"<=">
        | op<"≤">
        | op<">=">
        | op<"≥">
        | op<"⊆">
        | op<"⊇">
        | op<"⊂">
        | op<"⊃">
        ) BasicExpression
    | BasicExpression !compR op<"→"> BasicExpression
    | BasicExpression !iffXor ( kw<"iff"> | kw<"xor"> | op<"⇔"> | op<"⇎"> | op<"⊻"> ) BasicExpression

    | kw<"if"> v1expression kw<"then"> v1expression kw<"else"> v1expression kw<"end">
    | ( kw<"forall"> | "∀" ) "(" V1Bindings ":" v1expression ")"

    | BoundedExpression

    // logic expressions
    | !quant (kw<"exists"> | "∃") BasicExpression
    | !quant (kw<"exists"> | "∃") V1LogicalAbstractExpression
    | !not ( kw<"not"> | op<"¬"> ) BasicExpression
    | BasicExpression !and ( kw<"and"> | op<"∧"> ) BasicExpression
    | BasicExpression !or ( kw<"or"> | op<"∨"> ) BasicExpression
    | BasicExpression !impliesR ( kw<"implies"> | op<"⇒"> ) BasicExpression
    | BasicExpression !impliesL op<"⇐"> BasicExpression

    // restrict expression
    | BasicExpression !restrict ( op<"<:"> | op<":>"> ) BasicExpression

    // override expression
    | BasicExpression !override ( op<"<++"> | op<"++>"> ) BasicExpression
}

/* Application expressions are defined explicitly to highlight
 * the BasicId in these expressions.
 */
PartialApplicationExpression
    { BasicExpression !appl "[" V1NocommaActual? "]"
    | BasicExpression !appl "[" commaSep2<V1BasicActual> "]"
    }

ApplicationExpression
    { BasicExpression !appl "(" V1NocommaActual? ")"
    | BasicExpression !appl "(" commaSep2<V1BasicActual> ")"
    }

BoundedExpression
    { "(" v1expression? ( "," | ";" )? ")"
    | "{" v1expression? ( "," | ";" )? "}"
    }

V1Bindings
    { Bindings ( !bind kw<"where"> nonAbstractExpression )?
    | "(" V1Bindings ")"
    }

V1AbstractExpression
    { V1Bindings !abstract ":" v1expression
    | v1expression !abstract ( kw<"for"> | "|" | kw<"from">) V1Bindings
    }

V1LogicalAbstractExpression
    { V1Bindings !abstract ":" BasicExpression
    | V1Bindings !abstract ":" V1LogicalAbstractExpression
    | BasicExpression !abstract ( kw<"for"> | "|" | kw<"from">) V1Bindings
    | V1LogicalAbstractExpression !abstract ( kw<"for"> | "|" | kw<"from">) V1Bindings
    }

nonAbstractExpression
    { BasicExpression
    | UnionExpression { v1expression !union ";" v1expression }
    | ProductExpression { v1expression !product "," v1expression }
    | TripleEqualExpression { v1expression !tripleEqual (op<'≡'> | op<'≢'>) v1expression }
    }

v1expression
    { nonAbstractExpression
    | V1AbstractExpression
    }

nocommaExpression
    { BasicExpression
    | NocommaUnionExpression { nocommaExpression !union ";" nocommaExpression }
    | V1NocommaAbstractExpression
        { V1Bindings !abstract ":" nocommaExpression
        | nocommaExpression !abstract ( kw<"for"> | "|" | kw<"from">) V1Bindings
        }
    }

V1BasicActual { Operator ~operatorConflict | BasicExpression | "_..." | "_…" }

V1NocommaActual { Operator ~operatorConflict | nocommaExpression | "_..." | "_…" }

v1TopLevelExpression { Annotation* v1expression }

VarDecl
    { literal ~literalConflict
    | Operator ~operatorConflict
    | (id "..."? ~idConflict ) (( kw<"in"> | op<"∈"> ) BasicExpression)?
    }

Bindings { VarDecl ( !param "," VarDecl )* }

v1FormalsBracket { "[" Bindings? "]" }

v1FormalsParen { "(" Bindings? ")" }

@tokens {
    spaces[@export] { $[\u0009 \u000b\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]+ }
    newLine[@export] { $[\r\n\u2028\u2029] }

    idCharSingle {
        $[a-zA-Zα-ωΑ-Ω]
    }
    idCharInit {
        $[a-zA-Zα-ωΑ-Ω_]
    }
    idChar {
        $[a-zA-Zα-ωΑ-Ω_0-9]
    }
    basicIdentifier { idCharSingle | idCharInit idChar+ }
    BasicId { basicIdentifier }
    ConstructorId { "^" basicIdentifier }

    Operator
        { "."
        | "^"
        | "/"
        | "%"
        | "*"
        | "÷"
        | "×"
        | "⊗"
        | "⊙"
        | "-"
        | "+"
        | "⊕"
        | "∩"
        | "∪"
        | "⊔"
        | "⊓"
        | "="
        | "!="
        | "≈"
        | "∼"
        | "≠"
        | "<"
        | ">"
        | "<="
        | "≤"
        | ">="
        | "≥"
        | "∈"
        | "⊆"
        | "⊇"
        | "⊂"
        | "⊃"
        | "≼"
        | "≽"
        | "≺"
        | "≻"
        | "¬"
        | "∧"
        | "∨"
        | "→"
        | "←"
        | "⇒"
        | "⇐"
        | "≡"
        | "⇔"
        | "⊻"
        | "≢"
        | "⇎"
        | "<:"
        | ":>"
        | "<++"
        | "++>"
        | "++"
        }

    decimalLiteral { $[0-9]+ }
    octalLiteral { "0o" $[0-7]+ }
    hexadecimalLiteral { "0x" $[0-9A-Fa-f]+ }
    IntLiteral { decimalLiteral | octalLiteral | hexadecimalLiteral }
    SpecializeIntLiteral { "#" IntLiteral }

    exponent { $[eE] $[+-]? decimalLiteral }
    floatLiteral1 { decimalLiteral "." decimalLiteral? exponent? }
    floatLiteral2 { decimalLiteral exponent }
    floatLiteral3 { "." decimalLiteral exponent? }
    FloatLiteral { floatLiteral1 | floatLiteral2 | floatLiteral3 }

    DateLiteral { $[0-9] $[0-9] $[0-9] $[0-9] "-" $[0-9] $[0-9] "-" $[0-9] $[0-9] }
    hourMinuteDigits { $[0-9] $[0-9] ":" $[0-9] $[0-9] }
    timeDigits { $[0-9] $[0-9] ":" $[0-9] $[0-9] ":" $[0-9] $[0-9] }
    timezone { "Z" | $[+-]? hourMinuteDigits }
    DateTimeLiteral { DateLiteral "T" timeDigits timezone }

    BooleanLiteral { "true" | "false" }

    EscapeChar
        { '\\' ('\\'
            | '%'
            | $['"abefnrtv0-7]
            | $[0-7]$[0-7]
            | $[0123]$[0-7]$[0-7]
            | 'x' $[0-9a-fA-F]$[0-9a-fA-F]
            | 'u' $[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]
            | 'U' $[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]
            )
        }
    staticChar { !["\r\n\\%] }
    multiStaticChar { !["\\%] }

    staticSequence { staticChar | EscapeChar }
    multiStaticSequence { '"'? '"'? ( multiStaticChar | EscapeChar ) }
    StaticStringLiteral { '"' staticSequence* '"' }
    StaticMultilineStringLiteral { '"""' multiStaticSequence* '"""' }

    staticStringPart { staticSequence+ }
    staticMultilineStringPart { multiStaticSequence+ }

    DocstringLiteral { quote1 (!["\r\n\\] | EscapeChar)* quote1 }
    MultilineDocstringLiteral {
        quote3 ( quote1? quote1? (!["\\] | EscapeChar))* quote3
    }

    RelnameLiteral { ( ":" "^"? (basicIdentifier | "_") | ":[]" ) }
    RelnameStringLiteral { ":" StaticStringLiteral }
    RelnameMultilineStringLiteral { ":" StaticMultilineStringLiteral }

    QualifiedNameElem { ":" (BasicId | ConstructorId) | ":(" Operator ")" | "::" (BasicId | ConstructorId) | "::(" Operator ")" }
    InterpolationId { "%" basicIdentifier }

    quote1 { '"' }
    quote3 { '"""' }

    CharLiteral { "'" ( !['\\] | EscapeChar ) "'" }

    LineComment { "//" ![\n]* }
    BlockComment { "/*" ( ![*] | "*"+ ![/*] )* "*"+ "/" }

    @precedence { spaces newLine staticStringPart BlockComment LineComment DocstringLiteral }
    @precedence { spaces newLine staticMultilineStringPart BlockComment LineComment MultilineDocstringLiteral }
    @precedence { DateTimeLiteral DateLiteral FloatLiteral IntLiteral }
    @precedence { BooleanLiteral BasicId }
    @precedence { ConstructorId Operator }
    @precedence { FloatLiteral Operator }
    @precedence { "..." Operator ":" }
    @precedence { QualifiedNameElem ":" }
    @precedence { RelnameLiteral ":" }
    @precedence { BasicId "_" }
    @precedence { LineComment Operator }
    @precedence { MultilineDocstringLiteral DocstringLiteral }

}

kw<term> { @specialize[@name=Keyword]<BasicId, term> }

xkw<term> { @extend[@name=Keyword]<BasicId, term> }

emp<term> { @extend[@name=Emphasis]<BasicId, term> }

op<oper> { @extend[@name=OperatorKeyword]<Operator, oper> }

commaSep1<rule> { rule ( !param "," rule )* }

commaSep2<rule> { rule !param "," rule ( !param "," rule )* }

@top Program { declaration+ }

@skip { space | LineComment | BlockComment }

@precedence {
    field @left,
    appl @left,
    power @right,
    unary,
    param @left,
    mul @left,
    add @left,
    join @left,
    union @left,
    compL @left,
    compR @right,
    not,
    quant,
    and @left,
    or @left,
    impliesR @right,
    impliesL @left,
    iff @right,
    xor @right,
    relname @right,
    abstract @left,
    parenOp
}

declaration[@isGroup=Declaration] {
    DefinitionStatement |
    ValueTypeStatement |
    EntityTypeStatement |
    ConstraintStatement |
    ModuleStatement |
    UseStatement
}

/*
 * Docstring Statement
 */

Docstring {
    kw<"doc"> DocstringLiteral |
    kw<"doc"> MultilineDocstringLiteral
}

/*
 * Attribute Statement
 */

attributeKeyword {
    attrKw<"inline"> |
    attrKw<"function"> |
    attrKw<"ondemand">
}

AttributeParams { commaSep1<BaseLiteral> }

Attribute { "@" attributeKeyword ( "(" AttributeParams ")" )? }

/*
 * Declaration Statements
 */
prelude { Docstring? Attribute* }

params { FormalParamsBracket* FormalParamsParen? }

DefinitionStatement {
    prelude kw<"def"> LhsId params ( "=" Expression | "{" Expression "}" )
}

ValueTypeStatement {
    prelude kw<"value"> kw<"type"> LhsId ( params ( "=" Expression | "{" Expression "}" ) )?
}

EntityTypeStatement {
    prelude kw<"entity"> kw<"type"> LhsId ( params ( "=" Expression | "{" Expression "}" ) )?
}

ConstraintStatement {
    prelude kw<"ic"> LhsId? params ( "=" Expression | "{" Expression "}" )
}

ModuleStatement {
    prelude kw<"module"> LhsId FormalParamsBracket* declaration* kw<"end">
}

UseStatement {
    kw<"with"> Expression kw<"use"> ("..." | commaSep1<Alias>)
}

id { BasicId | type | kw<"type"> | kw<"entity"> | kw<"value"> }

ParenOpId { "(" Operator !parenOp ")" }

LhsId {
    id |
    ParenOpId |
    QualifiedName |
    emphasisKeyword
}

Alias { ( id | Operator ) ( kw<"as"> ( id | Operator ) )? }

QualifiedNameElem { BasicId ~idConflict | ParenOpId ~parenOpConflict }

QualifiedName { ( type | emphasisKeyword | QualifiedNameElem ) !relname (":" QualifiedNameElem)+ }

emphasisKeyword[@dynamicPrecedence=1] {
    emp<"output"> |
    emp<"insert"> |
    emp<"delete"> |
    emp<"abort"> |
    emp<"export">
}

type {
    relType<"Any"> |
    relType<"String"> |
    relType<"Int"> |
    relType<"Number"> |
    relType<"Char"> |
    relType<"Missing"> |
    relType<"Float"> |
    relType<"Floating"> |
    relType<"UnsignedInt"> |
    relType<"SignedInt"> |
    relType<"Rational"> |
    relType<"FixedDecimal"> |
    relType<"RelName"> |
    relType<"Entity"> |
    relType<"AutoNumber"> |
    relType<"Hash"> |
    relType<"FilePos"> |
    relType<"Date"> |
    relType<"DateTime"> |
    relType<"Year"> |
    relType<"Month"> |
    relType<"Week"> |
    relType<"Day"> |
    relType<"Hour"> |
    relType<"Minute"> |
    relType<"Second"> |
    relType<"Millisecond"> |
    relType<"Microsecond"> |
    relType<"Nanosecond"> |
    relType<"Pattern"> |
    relType<"Boolean">
}

/*
 * Literals
 */

RelnameLiteral { ( !relname ":" "^"? (basicIdentifier | "_") | ":[]" ) }
RelnameStringLiteral { !relname ":" StaticStringLiteral }
RelnameMultilineStringLiteral { !relname ":" StaticMultilineStringLiteral }

BaseLiteral {
    IntLiteral |
    FloatLiteral |
    RelnameLiteral |
    RelnameStringLiteral |
    RelnameMultilineStringLiteral |
    StaticStringLiteral |
    StaticMultilineStringLiteral |
    CharLiteral |
    DateLiteral |
    DateTimeLiteral
    // TODO add RAWSTRING_LITERAL
}

Literal {
    BaseLiteral |
    BooleanLiteral |
    SpecializeIntLiteral
    // TODO add Interpolation Literals
}

BasicExpression {
    id "..."? ~idConflict |
    ParenOpId ~parenOpConflict |
    QualifiedName |
    Literal ~literalConflict |
    SpecializeExpression |
    "_" |
    BasicExpression !field op<"."> BasicExpression |
    BasicExpression !appl "[" NocommaParam? "]" |
    BasicExpression !appl "(" NocommaParam? ")" |
    BasicExpression !appl "[" commaSep2<LogicalParam> "]" |
    BasicExpression !appl "(" commaSep2<LogicalParam> ")" |
    BasicExpression !power op<"^"> BasicExpression |
    !unary op<"-"> BasicExpression |
    BasicExpression !mul op<"/"> BasicExpression |
    BasicExpression !mul op<"%"> BasicExpression |
    BasicExpression !mul op<"*"> BasicExpression |
    BasicExpression !mul op<"÷"> BasicExpression |
    BasicExpression !mul op<"×"> BasicExpression |
    BasicExpression !mul op<"⊗"> BasicExpression |
    BasicExpression !mul op<"⊙"> BasicExpression |
    BasicExpression !add op<"+"> BasicExpression |
    BasicExpression !add op<"-"> BasicExpression |
    BasicExpression !add op<"∩"> BasicExpression |
    BasicExpression !add op<"⊕"> BasicExpression |
    BasicExpression !union op<"∪"> BasicExpression |
    BasicExpression !add op<"⊓"> BasicExpression |
    BasicExpression !union op<"⊔"> BasicExpression |
    BasicExpression !compL op<"="> BasicExpression |
    BasicExpression !compL op<"!="> BasicExpression |
    BasicExpression !compL op<"≈"> BasicExpression |
    BasicExpression !compL op<"∼"> BasicExpression |
    BasicExpression !compR op<"→"> BasicExpression |
    BasicExpression !compL op<"←"> BasicExpression |
    BasicExpression !compL op<"≼"> BasicExpression |
    BasicExpression !compL op<"≽"> BasicExpression |
    BasicExpression !compL op<"≺"> BasicExpression |
    BasicExpression !compL op<"≻"> BasicExpression |
    BasicExpression !compL op<"≠"> BasicExpression |
    BasicExpression !compL op<"<"> BasicExpression |
    BasicExpression !compL op<">"> BasicExpression |
    BasicExpression !compL op<"<="> BasicExpression |
    BasicExpression !compL op<"≤"> BasicExpression |
    BasicExpression !compL op<">="> BasicExpression |
    BasicExpression !compL op<"≥"> BasicExpression |
    BasicExpression !compL op<"⊆"> BasicExpression |
    BasicExpression !compL op<"⊇"> BasicExpression |
    BasicExpression !compL op<"⊂"> BasicExpression |
    BasicExpression !compL op<"⊃"> BasicExpression |
    "(" Expression? ( "," | ";" )? ")" |
    "{" Expression? ( "," | ";" )? "}" |
    kw<"if"> Expression kw<"then"> Expression kw<"else"> Expression kw<"end"> |
    ( kw<"forall"> | "∀" ) "(" Bindings ":" Expression ")"
}

LogicalExpression {
    BasicExpression |
    !quant (kw<"exists"> | "∃") LogicalExpression |
    !quant (kw<"exists"> | "∃") LogicalAbstractExpression |
    LogicalExpression !and ( kw<"and"> | op<"∧"> ) LogicalExpression |
    LogicalExpression !or ( kw<"or"> | op<"∨"> ) LogicalExpression |
    LogicalExpression !impliesR ( kw<"implies"> | op<"⇒"> ) LogicalExpression |
    LogicalExpression !impliesL op<"⇐"> LogicalExpression |
    !not ( kw<"not"> | op<"¬"> ) LogicalExpression |
    LogicalExpression !iff ( kw<"iff"> | op<"≡"> | op<"⇔"> ) LogicalExpression |
    LogicalExpression !xor ( kw<"xor"> | op<"≢"> | op<"⇎"> | op<"⊻"> ) LogicalExpression
}

Bindings {
    FormalParams ( kw<"where"> LogicalExpression )? |
    "(" Bindings ")"
}

AbstractExpression {
    Bindings !abstract ":" Expression |
    UnionExpression !abstract ( kw<"for"> | "|" | kw<"from">) Bindings
}

LogicalAbstractExpression {
    Bindings !abstract ":" LogicalExpression |
    LogicalExpression !abstract ( kw<"for"> | "|" | kw<"from">) Bindings
}

NocommaAbstractExpression {
    Bindings !abstract ":" NocommaExpression |
    NocommaUnionExpression !abstract ( kw<"for"> | "|" | kw<"from">) Bindings
}

RestrictExpression {
    LogicalExpression |
    RestrictExpression ( op<"<:"> | op<":>"> ) LogicalExpression
}

OverrideExpression {
    RestrictExpression |
    OverrideExpression ( op<"<++"> | op<"++>"> ) RestrictExpression
}

JoinExpression {
    OverrideExpression |
    JoinExpression !join "," OverrideExpression
}

UnionExpression { paramUnionExpr<UnionExpression, JoinExpression> }

Expression { UnionExpression | AbstractExpression }

SpecializeExpression { "#(" Expression ")" }

NocommaUnionExpression { paramUnionExpr<NocommaUnionExpression, OverrideExpression> }

NocommaExpression { NocommaUnionExpression | NocommaAbstractExpression }

LogicalParam { Operator ~operatorConflict | LogicalExpression }

NocommaParam { Operator ~operatorConflict | NocommaExpression }

FormalParam {
    Literal ~literalConflict |
    Operator ~operatorConflict |
    (id "..."? ~idConflict ) (( kw<"in"> | op<"∈"> ) BasicExpression)?
}

FormalParams { FormalParam ( !param "," FormalParam )* }

FormalParamsBracket { "[" FormalParams? "]" }

FormalParamsParen { "(" FormalParams? ")" }

@tokens {
    space { $[ \r\t\n]+ }

    idCharSingle {
        $[a-zA-Zα-ωΑ-Ω]
    }
    idCharInit {
        $[a-zA-Zα-ωΑ-Ω_]
    }
    idChar {
        $[a-zA-Zα-ωΑ-Ω_0-9]
    }
    basicIdentifier { idCharSingle | idCharInit idChar+ }
    BasicId { "^"? basicIdentifier }

    Operator {
        "." |
        "^" |
        "/" |
        "%" |
        "*" |
        "÷" |
        "×" |
        "⊗" |
        "⊙" |
        "-" |
        "+" |
        "⊕" |
        "∩" |
        "∪" |
        "⊔" |
        "⊓" |
        "=" |
        "!=" |
        "≈" |
        "∼" |
        "≠" |
        "<" |
        ">" |
        "<=" |
        "≤" |
        ">=" |
        "≥" |
        "∈" |
        "⊆" |
        "⊇" |
        "⊂" |
        "⊃" |
        "≼" |
        "≽" |
        "≺" |
        "≻" |
        "¬" |
        "∧" |
        "∨" |
        "→" |
        "←" |
        "⇒" |
        "⇐" |
        "≡" |
        "⇔" |
        "⊻" |
        "≢" |
        "⇎" |
        "<:" |
        ":>" |
        "<++" |
        "++>"
    }

    decimalLiteral { $[0-9]+ }
    octalLiteral { "0o" $[0-7]+ }
    hexadecimalLiteral { "0x" $[0-9A-Fa-f]+ }
    IntLiteral { decimalLiteral | octalLiteral | hexadecimalLiteral }
    SpecializeIntLiteral { "#" IntLiteral }

    exponent { $[eE] $[+-]? decimalLiteral }
    floatLiteral1 { decimalLiteral "." decimalLiteral? exponent? }
    floatLiteral2 { decimalLiteral exponent }
    floatLiteral3 { "." decimalLiteral exponent? }
    FloatLiteral { floatLiteral1 | floatLiteral2 | floatLiteral3 }

    DateLiteral { $[0-9] $[0-9] $[0-9] $[0-9] "-" $[0-9] $[0-9] "-" $[0-9] $[0-9] }
    hourMinuteDigits { $[0-9] $[0-9] ":" $[0-9] $[0-9] }
    timeDigits { $[0-9] $[0-9] ":" $[0-9] $[0-9] ":" $[0-9] $[0-9] }
    timezone { "Z" | $[+-]? hourMinuteDigits }
    DateTimeLiteral { DateLiteral "T" timeDigits timezone }

    BooleanLiteral { "true" | "false" }

    EscapeChar {
        '\\' ('\\' | '%' |
            $['"abefnrtv0-7] |
            $[0-7]$[0-7] |
            $[0123]$[0-7]$[0-7] |
            'x' $[0-9a-fA-F]$[0-9a-fA-F] |
            'u' $[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F] |
            'U' $[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F])
    }
    staticChar { !["\r\n\\%] }
    multiStaticChar { !["\\%] }

    staticSequence { staticChar | EscapeChar }
    multiStaticSequence { '"'? '"'? ( multiStaticChar | EscapeChar ) }
    StaticStringLiteral { '"' staticSequence* '"' }
    StaticMultilineStringLiteral { '"""' multiStaticSequence* '"""' }

    DocstringLiteral { '"' (!["\r\n\\] | EscapeChar)* '"' }
    MultilineDocstringLiteral { '"""' ( '"'? '"'? (!["\\] | EscapeChar))* '"""' }

    CharLiteral { "'" ( !['\\] | EscapeChar ) "'" }

    LineComment { "//" ![\r\n]* }
    BlockComment { "/*" ( ![*] | "*"+ ![/*] )* "*"+ "/" }

    @precedence { space BlockComment LineComment DocstringLiteral }
    @precedence { space BlockComment LineComment MultilineDocstringLiteral }
    @precedence { DateTimeLiteral DateLiteral FloatLiteral IntLiteral }
    @precedence { BooleanLiteral BasicId }
    @precedence { BasicId Operator }
    @precedence { FloatLiteral Operator }
    @precedence { "..." Operator ":" }
    @precedence { basicIdentifier "_" }
    @precedence { BasicId "_" }
    @precedence { LineComment Operator }

}

kw<term> { @specialize[@name=Keyword]<BasicId, term> }

attrKw<term> { @extend[@name=AttributeKeyword]<BasicId, term> }

emp<term> { @extend[@name=Emphasis]<BasicId, term> }

relType<term> { @specialize[@name=Type]<BasicId, term> }

op<oper> { @extend[@name=OperatorKeyword]<Operator, oper> }

commaSep1<rule> { rule ( !param "," rule )* }

commaSep2<rule> { rule !param "," rule ( !param "," rule )* }

paramUnionExpr<expr, argExpr> {
    argExpr |
    expr !union ";" argExpr
}

@detectDelim

@top Rel { declaration+ }

@skip { spaces | newLine | LineComment | BlockComment }

@precedence {
    field @left,
    appl @left,
    power @right,
    unary,
    param @left,
    mul @left,
    add @left,
    join @left,
    union @left,
    compL @left,
    compR @right,
    not,
    quant,
    and @left,
    or @left,
    impliesR @right,
    impliesL @left,
    iff @right,
    xor @right,
    relname @left,
    abstract @left,
    parenOp
}

declaration[@isGroup=Declaration] {
    DefinitionStatement |
    ValueTypeStatement |
    EntityTypeStatement |
    ConstraintStatement |
    ModuleStatement |
    UseStatement
}

/*
 * Docstring Statement
 */

Docstring {
    kw<"doc"> DocstringLiteral |
    kw<"doc"> MultilineDocstringLiteral
}

/*
 * Attribute Statement
 */

attributeKeyword {
    attrKw<"function"> |
    attrKw<"inline"> |
    attrKw<"ondemand"> |
    attrKw<"outline"> |
    attrKw<"static">
}

AttributeParams { commaSep1<BaseLiteral> }

Attribute { "@" attributeKeyword ( "(" AttributeParams ")" )? }

/*
 * Declaration Statements
 */

DefinitionStatement {
    Docstring? Attribute* kw<"def"> LhsId FormalParamsBracket* FormalParamsParen? ( "=" Expression | "{" Expression "}" )
}

ValueTypeStatement {
    Docstring? Attribute* kw<"value"> kw<"type"> LhsId ( FormalParamsBracket* FormalParamsParen? ( "=" Expression | "{" Expression "}" ) )?
}

EntityTypeStatement {
    Docstring? Attribute* kw<"entity"> kw<"type"> LhsId ( FormalParamsBracket* FormalParamsParen? ( "=" Expression | "{" Expression "}" ) )?
}

ConstraintStatement {
    Docstring? Attribute* kw<"ic"> LhsId? FormalParamsBracket* FormalParamsParen? ( "=" Expression | "{" Expression "}" )
}

ModuleStatement {
    Docstring? Attribute* kw<"module"> LhsId FormalParamsBracket* declaration* kw<"end">
}

UseStatement {
    kw<"with"> Expression kw<"use"> ("..." | commaSep1<Alias>)
}

id { BasicId | type ~typeConflict | kw<"type"> | kw<"entity"> | kw<"value"> }

ParenOpId { "(" Operator !parenOp ")" }

LhsId {
    id |
    ParenOpId |
    QualifiedName |
    emphasisKeyword
}

AliasId { ( id | Operator ) }

Alias { ( id | Operator ) ( kw<"as"> AliasId )? }

QualifiedNameId { emphasisKeyword | BasicId ~idConflict | ParenOpId ~parenOpConflict | type ~typeConflict }

QualifiedName { QualifiedNameId QualifiedNameElem+ }

emphasisKeyword[@dynamicPrecedence=1] {
    emp<"output"> |
    emp<"insert"> |
    emp<"delete"> |
    emp<"abort"> |
    emp<"export">
}

type {
    relType<"Any"> |
    relType<"String"> |
    relType<"Int"> |
    relType<"Number"> |
    relType<"Char"> |
    relType<"Missing"> |
    relType<"Float"> |
    relType<"Floating"> |
    relType<"UnsignedInt"> |
    relType<"UInt"> |
    relType<"SignedInt"> |
    relType<"Rational"> |
    relType<"FixedDecimal"> |
    relType<"RelName"> |
    relType<"Entity"> |
    relType<"AutoNumber"> |
    relType<"Hash"> |
    relType<"FilePos"> |
    relType<"Date"> |
    relType<"DateTime"> |
    relType<"Year"> |
    relType<"Month"> |
    relType<"Week"> |
    relType<"Day"> |
    relType<"Hour"> |
    relType<"Minute"> |
    relType<"Second"> |
    relType<"Millisecond"> |
    relType<"Microsecond"> |
    relType<"Nanosecond"> |
    relType<"Boolean">
}

/*
 * Literals
 */


/*
 * Raw strings can't be recognized as in ANTLR parser
 * since commands are not supported in lezer parser,
 * so the implementation here is limited to a maximum of 7 quotes
 * TODO generalize to support N quotes
 */
RawStringSequence {
    quote1 (rawChar)* quote1 |
    quote3 (rawChar | quote1)* quote3 |
    quote5 (rawChar | quote1 | quote3)* quote5 |
    quote7 (rawChar | quote1 | quote3 | quote5)* quote7
}

RawStringLiteral {
    kw<"raw"> RawStringSequence
}

Interpolation {
    InterpolationId |
    "%(" Expression ")"
}

InterpolationLiteral {
    quote1 staticStringPart? Interpolation (staticStringPart | Interpolation)* quote1
}

InterpolationMultilineLiteral {
    quote3 staticMultilineStringPart? Interpolation (staticMultilineStringPart | Interpolation)* quote3
}

RelnameLiteral { ( !relname ":" "^"? (basicIdentifier | "_") | ":[]" ) }
RelnameStringLiteral { !relname ":" StaticStringLiteral }
RelnameMultilineStringLiteral { !relname ":" StaticMultilineStringLiteral }

BaseLiteral {
    IntLiteral |
    FloatLiteral |
    RelnameLiteral |
    RelnameStringLiteral |
    RelnameMultilineStringLiteral |
    StaticStringLiteral |
    StaticMultilineStringLiteral |
    CharLiteral |
    DateLiteral |
    DateTimeLiteral |
    RawStringLiteral
}

Literal {
    BaseLiteral |
    BooleanLiteral |
    SpecializeIntLiteral |
    InterpolationLiteral |
    InterpolationMultilineLiteral
}

/*
 * Expressions
 */

BasicExpression {
    id "..."? ~idConflict |
    ParenOpId ~parenOpConflict |
    QualifiedName |
    Literal ~literalConflict |
    SpecializeExpression |
    "_" |
    BasicExpression !field op<"."> BasicExpression |
    PartialApplicationExpression |
    ApplicationExpression |
    BasicExpression !power op<"^"> BasicExpression |
    !unary op<"-"> BasicExpression |
    BasicExpression !mul op<"/"> BasicExpression |
    BasicExpression !mul op<"%"> BasicExpression |
    BasicExpression !mul op<"*"> BasicExpression |
    BasicExpression !mul op<"÷"> BasicExpression |
    BasicExpression !mul op<"×"> BasicExpression |
    BasicExpression !mul op<"⊗"> BasicExpression |
    BasicExpression !mul op<"⊙"> BasicExpression |
    BasicExpression !add op<"+"> BasicExpression |
    BasicExpression !add op<"-"> BasicExpression |
    BasicExpression !add op<"∩"> BasicExpression |
    BasicExpression !add op<"⊕"> BasicExpression |
    BasicExpression !union op<"∪"> BasicExpression |
    BasicExpression !add op<"⊓"> BasicExpression |
    BasicExpression !union op<"⊔"> BasicExpression |
    BasicExpression !compL op<"="> BasicExpression |
    BasicExpression !compL op<"!="> BasicExpression |
    BasicExpression !compL op<"≈"> BasicExpression |
    BasicExpression !compL op<"∼"> BasicExpression |
    BasicExpression !compR op<"→"> BasicExpression |
    BasicExpression !compL op<"←"> BasicExpression |
    BasicExpression !compL op<"≼"> BasicExpression |
    BasicExpression !compL op<"≽"> BasicExpression |
    BasicExpression !compL op<"≺"> BasicExpression |
    BasicExpression !compL op<"≻"> BasicExpression |
    BasicExpression !compL op<"≠"> BasicExpression |
    BasicExpression !compL op<"<"> BasicExpression |
    BasicExpression !compL op<">"> BasicExpression |
    BasicExpression !compL op<"<="> BasicExpression |
    BasicExpression !compL op<"≤"> BasicExpression |
    BasicExpression !compL op<">="> BasicExpression |
    BasicExpression !compL op<"≥"> BasicExpression |
    BasicExpression !compL op<"⊆"> BasicExpression |
    BasicExpression !compL op<"⊇"> BasicExpression |
    BasicExpression !compL op<"⊂"> BasicExpression |
    BasicExpression !compL op<"⊃"> BasicExpression |
    BoundedExpression |
    kw<"if"> Expression kw<"then"> Expression kw<"else"> Expression kw<"end"> |
    ( kw<"forall"> | "∀" ) "(" Bindings ":" Expression ")"
}

PartialApplicationExpression {
    BasicExpression !appl "[" NocommaParam? "]" |
    BasicExpression !appl "[" commaSep2<LogicalParam> "]"
}

ApplicationExpression {
    BasicExpression !appl "(" NocommaParam? ")" |
    BasicExpression !appl "(" commaSep2<LogicalParam> ")"
}

BoundedExpression {
    "(" Expression? ( "," | ";" )? ")" |
    "{" Expression? ( "," | ";" )? "}"
}

LogicalExpression {
    BasicExpression |
    !quant (kw<"exists"> | "∃") LogicalExpression |
    !quant (kw<"exists"> | "∃") LogicalAbstractExpression |
    LogicalExpression !and ( kw<"and"> | op<"∧"> ) LogicalExpression |
    LogicalExpression !or ( kw<"or"> | op<"∨"> ) LogicalExpression |
    LogicalExpression !impliesR ( kw<"implies"> | op<"⇒"> ) LogicalExpression |
    LogicalExpression !impliesL op<"⇐"> LogicalExpression |
    !not ( kw<"not"> | op<"¬"> ) LogicalExpression |
    LogicalExpression !iff ( kw<"iff"> | op<"≡"> | op<"⇔"> ) LogicalExpression |
    LogicalExpression !xor ( kw<"xor"> | op<"≢"> | op<"⇎"> | op<"⊻"> ) LogicalExpression
}

Bindings {
    FormalParams ( kw<"where"> LogicalExpression )? |
    "(" Bindings ")"
}

AbstractExpression {
    Bindings !abstract ":" Expression |
    UnionExpression !abstract ( kw<"for"> | "|" | kw<"from">) Bindings
}

LogicalAbstractExpression {
    Bindings !abstract ":" LogicalExpression |
    LogicalExpression !abstract ( kw<"for"> | "|" | kw<"from">) Bindings
}

NocommaAbstractExpression {
    Bindings !abstract ":" NocommaExpression |
    NocommaUnionExpression !abstract ( kw<"for"> | "|" | kw<"from">) Bindings
}

RestrictExpression {
    LogicalExpression |
    RestrictExpression ( op<"<:"> | op<":>"> ) LogicalExpression
}

OverrideExpression {
    RestrictExpression |
    OverrideExpression ( op<"<++"> | op<"++>"> ) RestrictExpression
}

JoinExpression {
    OverrideExpression |
    JoinExpression !join "," OverrideExpression
}

UnionExpression {
    JoinExpression |
    UnionExpression !union ";" JoinExpression
}

Expression { UnionExpression | AbstractExpression }

SpecializeExpression { "#(" Expression ")" }

NocommaUnionExpression {
    OverrideExpression |
    NocommaUnionExpression !union ";" OverrideExpression
}

NocommaExpression { NocommaUnionExpression | NocommaAbstractExpression }

LogicalParam { Operator ~operatorConflict | LogicalExpression }

NocommaParam { Operator ~operatorConflict | NocommaExpression }

FormalParam {
    Literal ~literalConflict |
    Operator ~operatorConflict |
    (id "..."? ~idConflict ) (( kw<"in"> | op<"∈"> ) BasicExpression)?
}

FormalParams { FormalParam ( !param "," FormalParam )* }

FormalParamsBracket { "[" FormalParams? "]" }

FormalParamsParen { "(" FormalParams? ")" }

@tokens {
    spaces[@export] { $[\u0009 \u000b\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]+ }
    newLine[@export] { $[\r\n\u2028\u2029] }

    idCharSingle {
        $[a-zA-Zα-ωΑ-Ω]
    }
    idCharInit {
        $[a-zA-Zα-ωΑ-Ω_]
    }
    idChar {
        $[a-zA-Zα-ωΑ-Ω_0-9]
    }
    basicIdentifier { idCharSingle | idCharInit idChar+ }
    BasicId { "^"? basicIdentifier }

    Operator {
        "." |
        "^" |
        "/" |
        "%" |
        "*" |
        "÷" |
        "×" |
        "⊗" |
        "⊙" |
        "-" |
        "+" |
        "⊕" |
        "∩" |
        "∪" |
        "⊔" |
        "⊓" |
        "=" |
        "!=" |
        "≈" |
        "∼" |
        "≠" |
        "<" |
        ">" |
        "<=" |
        "≤" |
        ">=" |
        "≥" |
        "∈" |
        "⊆" |
        "⊇" |
        "⊂" |
        "⊃" |
        "≼" |
        "≽" |
        "≺" |
        "≻" |
        "¬" |
        "∧" |
        "∨" |
        "→" |
        "←" |
        "⇒" |
        "⇐" |
        "≡" |
        "⇔" |
        "⊻" |
        "≢" |
        "⇎" |
        "<:" |
        ":>" |
        "<++" |
        "++>"
    }

    decimalLiteral { $[0-9]+ }
    octalLiteral { "0o" $[0-7]+ }
    hexadecimalLiteral { "0x" $[0-9A-Fa-f]+ }
    IntLiteral { decimalLiteral | octalLiteral | hexadecimalLiteral }
    SpecializeIntLiteral { "#" IntLiteral }

    exponent { $[eE] $[+-]? decimalLiteral }
    floatLiteral1 { decimalLiteral "." decimalLiteral? exponent? }
    floatLiteral2 { decimalLiteral exponent }
    floatLiteral3 { "." decimalLiteral exponent? }
    FloatLiteral { floatLiteral1 | floatLiteral2 | floatLiteral3 }

    DateLiteral { $[0-9] $[0-9] $[0-9] $[0-9] "-" $[0-9] $[0-9] "-" $[0-9] $[0-9] }
    hourMinuteDigits { $[0-9] $[0-9] ":" $[0-9] $[0-9] }
    timeDigits { $[0-9] $[0-9] ":" $[0-9] $[0-9] ":" $[0-9] $[0-9] }
    timezone { "Z" | $[+-]? hourMinuteDigits }
    DateTimeLiteral { DateLiteral "T" timeDigits timezone }

    BooleanLiteral { "true" | "false" }

    EscapeChar {
        '\\' ('\\' | '%' |
            $['"abefnrtv0-7] |
            $[0-7]$[0-7] |
            $[0123]$[0-7]$[0-7] |
            'x' $[0-9a-fA-F]$[0-9a-fA-F] |
            'u' $[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F] |
            'U' $[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F]$[0-9a-fA-F])
    }
    staticChar { !["\r\n\\%] }
    multiStaticChar { !["\\%] }

    staticSequence { staticChar | EscapeChar }
    multiStaticSequence { '"'? '"'? ( multiStaticChar | EscapeChar ) }
    StaticStringLiteral { '"' staticSequence* '"' }
    StaticMultilineStringLiteral { '"""' multiStaticSequence* '"""' }

    staticStringPart { staticSequence+ }
    staticMultilineStringPart { multiStaticSequence+ }

    DocstringLiteral { '"' (!["\r\n\\] | EscapeChar)* '"' }
    MultilineDocstringLiteral { '"""' ( '"'? '"'? (!["\\] | EscapeChar))* '"""' }

    QualifiedNameElem { ":" BasicId | ":(" Operator ")" }
    InterpolationId { "%" basicIdentifier }

    quote1 { '"' }
    quote3 { '"""' }
    quote5 { '"""""' }
    quote7 { '"""""""' }
    rawChar { !["] }

    CharLiteral { "'" ( !['\\] | EscapeChar ) "'" }

    LineComment { "//" ![\n]* }
    BlockComment { "/*" ( ![*] | "*"+ ![/*] )* "*"+ "/" }

    @precedence { rawChar spaces newLine BlockComment LineComment DocstringLiteral staticStringPart }
    @precedence { rawChar spaces newLine BlockComment LineComment MultilineDocstringLiteral staticMultilineStringPart }
    @precedence { DateTimeLiteral DateLiteral FloatLiteral IntLiteral }
    @precedence { BooleanLiteral BasicId }
    @precedence { BasicId Operator }
    @precedence { FloatLiteral Operator }
    @precedence { "..." Operator ":" }
    @precedence { QualifiedNameElem ":" }
    @precedence { basicIdentifier "_" }
    @precedence { BasicId "_" }
    @precedence { LineComment Operator }

}

kw<term> { @specialize[@name=Keyword]<BasicId, term> }

attrKw<term> { @extend[@name=AttributeKeyword]<BasicId, term> }

emp<term> { @extend[@name=Emphasis]<BasicId, term> }

relType<term> { @specialize[@name=Type]<BasicId, term> }

op<oper> { @extend[@name=OperatorKeyword]<Operator, oper> }

commaSep1<rule> { rule ( !param "," rule )* }

commaSep2<rule> { rule !param "," rule ( !param "," rule )* }

@detectDelim
